(load "senva/util.snv")

; define contents
(define window (js "window"))
(define document (js "document"))
(define canvas ((-> document "getElementById") "main-canvas"))
(define context ((-> canvas "getContext") "2d"))

; define sound
(define prop-sound ((-> document "createElement") "audio"))
(setat prop-sound "id" "click-sound")
(setat prop-sound "src" "prop.wav")
(setat prop-sound "volume" 0.2)
(setat prop-sound "preload" "auto")

(define inside (lambda (obj x y)
				 (and (< (obj 'x) x)
					  (< x (+ (obj 'x) (obj 'width)))
					  (< (obj 'y) y)
					  (< y (+ (obj 'y) (obj 'height))))))

; define classes
(! obj::def view (x 0 y 0 width 0 height 0 name ""))
(! obj::def clickable (click (lambda (this x y)
							   (print (sprint "click: " (this 'name)))))
   (view))
(! obj::def dragable (draging nil ofst-x 0 ofst-y 0
					  drag (lambda (this x y)
							 (do (this 'x (- x (this 'ofst-x)))
							     (this 'y (- y (this 'ofst-y))))))
   (view))
(! obj::def rect (color "#000000"
				  init (lambda (this x- y- w h c)
						 (do (this 'x x-)
						     (this 'y y-)
						     (this 'width w)
						     (this 'height h)
							 (if c (this 'color c))
							 (this 'name
								   (sprint "<rect (" x- "," y- "," w "," h ")>"))))
				  draw (lambda (this context)
						 (do (setat context "fillStyle" (this 'color))
							 ((-> context "fillRect") (this 'x) (this 'y)
												  (this 'width) (this 'height)))))
   (view))
(! obj::def drect () (dragable rect))
(! obj::def text (txt ""
				  color "#000000"
				  font "10px sans-serif"
				  init (lambda (this txt- x- y- c f)
							(do (this 'txt txt-)
							    (this 'x x-)
							    (this 'y y-)
							    (if c (this 'color c))
								(if f (this 'font f))
							    (this 'name (sprint "<text \"" txt- "\">"))))
				  draw (lambda (this context)
						 (! let ((splited (split (this 'txt) "\n"))
								 (fsize ((js "parseInt") (this 'font))))
							(do (setat context "fillStyle" (this 'color))
							  (map
								(! fn ((-> context "fillText")
									   (nth splited $0)
									   (+ (this 'x) fsize)
									   (+ (this 'y) (* fsize (+ $0 1)))))
								(range 0 (length splited)))))))
   (view))
(! obj::def typing-text (rawtxt ""
						 prev -1
						 wait 0
						 init (lambda (this txt- wait-ms x- y- c f)
								(do (this 'rawtxt txt-)
								    (this 'wait wait-ms)
								    (this 'x x-)
								    (this 'y y-)
								    (if c (this 'color c))
									(if f (this 'font f))
									(this 'name
										  (sprint "<typing-text \"" txt- "\">"))))
						 anime (lambda (this ts)
								 (if (equal (this 'prev) -1)
								   (this 'prev ts)
								   (! let ((tsiz (int (/ (- ts (this 'prev))
													   (this 'wait))))
										 (tlen (length (this 'txt)))
										 (rtlen (length (this 'rawtxt))))
									(if (and (< tlen rtlen)
											 (< 0 tsiz))
								   (do (this 'prev ts)
									   (this 'txt
											 (sprint (this 'txt)
													 (substr (this 'rawtxt)
															 tlen
															 (min rtlen
																  (+ tlen tsiz)))))))))))
   (text))
(! obj::def prompt (txts (queu)
					term " ▼ "
					ttxt nil
					rect nil
					init (lambda (this txts- wait-ms x- y- w h tc rc f)
						   (do (this 'txts (to-queu
											 (map (! fn (sprint $0 (this 'term)))
												  (to-list txts-))))
							   (this 'ttxt (obj::new 'typing-text))
							   (this 'rect (obj::new 'rect))
							   (this 'x x-)
							   (this 'y y-)
							   (this 'width w)
							   (this 'height h)
							   (((this 'ttxt) 'init) (popqueu (this 'txts))
													 wait-ms x- y- tc f)
							   (((this 'rect) 'init) x- y- w h rc)
							   (this 'name
									 (sprint "<prompt \"" (this 'rawtxt) "\">"))))
					add-text (lambda (this txt-)
							  (pushqueu (this 'txts) (sprint txt- (this 'term))))
					draw (lambda (this context)
						   (do (((this 'rect) 'draw) context)
							   (((this 'ttxt) 'draw) context)
							   ))
					anime (lambda (this ts)
							(((this 'ttxt) 'anime) ts))
				    click (lambda (this x y)
							(do (if (equal ((this 'ttxt) 'rawtxt)
										   ((this 'ttxt) 'txt))
								  (! aif (popqueu (this 'txts))
									 (do ((this 'ttxt) 'rawtxt it)
									     ((this 'ttxt) 'txt "")
										 ((this 'ttxt) 'prev -1)
										 ((-> prop-sound "play"))
										 ))
								  ((this 'ttxt) 'txt ((this 'ttxt) 'rawtxt))
								  ))))
   (clickable))
(! obj::def image (img nil
				  init (lambda (this src x- y- w h)
						 (do (this 'img (new "Image"))
						     (setat (this 'img) "src" src)
							 (setat (-> (this 'img) "style") "position" "absolute")
							 (this 'x x-)
							 (this 'y y-)
							 (this 'width w)
							 (this 'height h)
							 (this 'name (sprint "<image \"" src "\">"))))
				  draw (lambda (this context)
						  ((-> context "drawImage") (this 'img)
													(this 'x)
													(this 'y)
													(this 'width)
													(this 'height))))
   (view))

; set views
(define scene-controller nil)
(! let ((rct1 (obj::new 'rect))
		(drct1 (obj::new 'drect))
		(txt1 (obj::new 'text))
		(chr1 (obj::new 'image))
		(ttxt1 (obj::new 'typing-text))
		(prop1 (obj::new 'prompt))
		)
	(do ((txt1 'init) "Hello, World!" 250 60 "#000000")
		(! push scene-controller txt1)

		((ttxt1 'init) "animated string." 1400 250 160)
		(! push scene-controller ttxt1)

		((prop1 'init) ["first."] 120 60 240 100 24 "#FFFFFF" "#555555")
		((prop1 'add-text) "message\nclick me.")
		((prop1 'add-text) "あめんぼあかいな\nあいうえお.")
		((prop1 'add-text) "endprop.")
		(! push scene-controller prop1)

		((chr1 'init) "img.png" 10 20 200 247)
	    (! push scene-controller chr1)

		((drct1 'init) 200 100 200 80 "#AA3333")
		(! push scene-controller drct1)

		((rct1 'init) 20 30 200 247 "#3333AA")
		(! push scene-controller rct1)
		))

(define canvas-ofst ((-> canvas "getBoundingClientRect")))

; set click events
((-> canvas "addEventListener")
 "click" (lambda (e) (! let* ((cx (- (+ (-> window "scrollX") (-> e "clientX"))
									 (-> canvas-ofst "left")))
							  (cy (- (+ (-> window "scrollY") (-> e "clientY"))
									 (-> canvas-ofst "top")))
							  (celm (find-if (! fn (and (obj::isa $0 'clickable)
														(inside $0 cx cy)))
											(reverse scene-controller))))
						(if celm ((celm 'click) cx cy)))))

; set ondown events
(! let ((ondown (lambda (e)
				  (! let* ((cx (- (+ (-> window "scrollX") (-> e "clientX"))
								  (-> canvas-ofst "left")))
						   (cy (- (+ (-> window "scrollY") (-> e "clientY"))
								  (-> canvas-ofst "top")))
						   (celm (find-if (! fn (and (obj::isa $0 'dragable)
													 (inside $0 cx cy)))
											(reverse scene-controller))))
						(if celm (do (celm 'draging t)
								     (celm 'ofst-x (- cx (celm 'x)))
									 (celm 'ofst-y (- cy (celm 'y))))))))
		(onup (lambda (e) (map (! fn (if (obj::isa $0 'dragable) ($0 'draging nil)))
							   scene-controller)))
		(move (lambda (e)
				(! let* ((cx (- (+ (-> window "scrollX") (-> e "clientX"))
								(-> canvas-ofst "left")))
						 (cy (- (+ (-> window "scrollY") (-> e "clientY"))
								(-> canvas-ofst "top")))
						 (celm (find-if (! fn (and (obj::isa $0 'dragable)
												   ($0 'draging)))
										scene-controller)))
						(if celm ((celm 'drag) cx cy))))))
   (do ((-> canvas "addEventListener") "mousedown" ondown)
	   ((-> canvas "addEventListener") "touchstart" ondown)
	   ((-> canvas "addEventListener") "mouseup" onup)
	   ((-> canvas "addEventListener") "touchend" onup)
	   ((-> canvas "addEventListener") "mousemove" move)
	   ((-> canvas "addEventListener") "touchmove" move)))

; set loop events
(! letrec ((loop (lambda (ts)
				   (do ((-> context "clearRect") 0 0 (-> canvas "width")
												 (-> canvas "height"))
					   (map (! fn (do (! aif ($0 'anime) (it ts))
									(($0 'draw) context)))
							scene-controller)
					   ((-> context "clearRect") 0 0 (-> canvas "width")
												     (-> canvas "height"))
					   ((-> window "requestAnimationFrame") loop)))))
   ((-> window "requestAnimationFrame") loop))

