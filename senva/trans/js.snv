(load "senva/interpreter.snv")
(load "senva/file.snv")

(define trans::js::encode
  (lambda (expr)
	(if (atom expr)
	  (! aif (cadr (assocdr trans::js::env expr)) (sprint it) (trans::js::put expr))
	  (if (eq '<symb> (type (car expr)))
		(! aif (car (assocdr trans::js::env (car expr)))
		   (it (cdr expr))
		   (sprint (car expr) "(" (trans::js::array (cdr expr)) ")"))
		(sprint "(" (trans::js::encode (car expr)) ")"
				"(" (trans::js::array (cdr expr)) ")")))))

;(! let ((esc-seqs (zip (to-list "\\\"\a\b\f\n\r\t\v\0") (to-list "\\\"abfnrtv0")))
(define trans::js::escape
  (! let ((esc-seqs (zip (to-list "\\\"\a\b\f\n\r\t\v\0")
						 (map to-list '("\\\\" "\\\"" "\\x07" "\\b" "\\f"
										"\\n" "\\r" "\\t" "\\v" "\\0"))))
		  (esc (car (to-list "\\"))))
	 (lambda (str) (string (reduce (! fn (! aif (assoc esc-seqs $1)
											(append (cadr it) $0)
											(cons $1 $0)))
								   (nreverse (to-list str)) ())))))

(define trans::js::put
  (lambda (obj)
	(if (eq '<strn> (type obj))
	  (sprint "\"" (trans::js::escape obj) "\"")
	  (sprint obj))))

(define trans::js::quote-put
  (lambda (obj)
	(! case (type obj)
	   ('<symb> (sprint "new Symb(\"" obj "\")")
		'<cons> (sprint "new Cons("
						(trans::js::quote-put (car obj)) ", "
						(trans::js::quote-put (cdr obj)) ")")
		t (trans::js::put obj)))))

(define trans::js::quasiquote-put
  (lambda (obj)
	(! case (type obj)
	   ('<symb> (sprint "new Symb(\"" obj "\")")
		'<cons> (if (eq 'unquote (car obj))
				  (trans::js::encode (cadr obj))
				  (reduce
					(lambda (acm e)
					  (if (eq 'splicing (car e))
						(sprint "nconc(" (trans::js::encode (cadr e)) ", " acm ")")
						(sprint "nconc(l(" (trans::js::quasiquote-put e) "), " acm ")")))
					(reverse obj) "nil"))
		t (trans::js::put obj)))))

(define trans::js::array
  (lambda (arr) (join (map trans::js::encode arr) ", ")))

(define trans::js::bind-args
  (! letrec ((seekform (lambda (tree acc)
						 (if (atom tree)
						   (list (list acc tree))
						   (append (seekform (car tree) (cons 'safecar acc))
								   (if (cdr tree)
									 (seekform (cdr tree) (cons 'safecdr acc)))))))
			 (shiftargs (lambda (rargs cnt)
						 (if rargs
						   (if (atom rargs)
							 (list (sprint "let " rargs
										   " = vect2cons(__sys_args.slice(" cnt "))"))
							 (append (map (lambda ((accessor sym))
											(sprint "let " sym " = "
													(join (map (! fn (sprint $0 "("))
															   accessor) "")
													"__sys_args[" cnt "]"
													(join (times (length accessor)
																 ")") "")))
										  (seekform (car rargs)))
									 (shiftargs (cdr rargs) (+ cnt 1))))))))
   (lambda (args)
	 (if (atom args)
	   (list (sprint "let " args " = vect2cons(Array.from(arguments))"))
	   (cons "let __sys_args = Array.from(arguments)"
			 (shiftargs args 0))))))

(define trans::js::env ())
(define trans::js::regist
  (lambda (sym form alt)
	`(! push trans::js::env (list ',sym (lambda (args) ,form) ,alt))))

(define trans::js::regist-func
  (lambda (sym fsym)
	`(! push trans::js::env
		(list ',sym
			  (lambda (args) (sprint ',fsym "(" (trans::js::array args) ")"))
			  ',fsym))))

(define trans::js::regist-op
  (lambda (sym op default alt)
	`(! push trans::js::env
	   (list ',sym
			  (lambda (args)
				(if (> 1 (length args))
				  (sprint ,default)
				  (sprint "(" (join (map trans::js::encode args) ,op) ")")))
			  ,alt))))

(! trans::js::regist if (sprint "(" (trans::js::encode (car args)) " !== nil)"
						" ? " (trans::js::encode (cadr args))
						" : " (trans::js::encode (caddr args)))
   "seekenv(genv, new Symb(\"if\"))")

(! trans::js::regist quote (trans::js::quote-put (car args))
   "seekenv(genv, new Symb(\"quote\"))")

(! trans::js::regist lambda (if (flatlistp (car args))
					  (sprint "(function ("
							  (trans::js::array (car args)) ") {"
							  "return " (trans::js::encode (cadr args)) "})")
					  (sprint "(function () { try {"
							  (join (map (! fn (sprint $0 "; "))
										 (trans::js::bind-args (car args))) "")
							  "return " (trans::js::encode (cadr args))
							  "} catch (__sys_erro) {throw new Erro(ErroId.Type, `cannot bind: "
							  (car args)
							  " and ${lprint(vect2cons(Array.from(arguments)))}`)}})"))
   "seekenv(genv, new Symb(\"lambda\"))")

(! trans::js::regist ! (trans::js::encode (senva::expand-syntax-proc
									(car args) (cdr args) (environment)))
   "seekenv(genv, new Symb(\"!\"))")

(! trans::js::regist define (sprint "(function () {"
							(car args) " = " (trans::js::encode (cadr args))
							"; return " (trans::js::quote-put (car args)) "})()")
   "seekenv(genv, new Symb(\"define\"))")

(! trans::js::regist setq (sprint "(function () {"
						  (car args) " = " (trans::js::encode (cadr args))
						  "; return " (car args) "})()")
   "seekenv(genv, new Symb(\"setq\"))")

(! trans::js::regist do (! let ((jscs (map trans::js::encode args)))
						   (sprint "(function () {"
								   (join (rcons (tail-drop jscs 1)
												(sprint "return " (back jscs)))
										 "; ") "})()"))
   "seekenv(genv, new Symb(\"do\"))")

(! trans::js::regist quasiquote
   (trans::js::quasiquote-put (car args))
   "seekenv(genv, new Symb(\"quasiquote\"))")

(! trans::js::regist catch (sprint "(function () {try {return "
						   (trans::js::encode (cadr args))
						   "} catch (__sys_erro) {return "
						   (trans::js::encode (car args))
						   "(__sys_erro.eid, __sys_erro.estr)}})()")
   "seekenv(genv, new Symb(\"catch\"))")

(! trans::js::regist environment "genv" "seekenv(genv, new Symb(\"environment\"))"); TODO

(! trans::js::regist js (car args) 'eval)

(! trans::js::regist new (sprint "new " (car args)
							   "(" (trans::js::array (cdr args)) ")") 'lnew)

(! trans::js::regist -> (sprint (join (cons (trans::js::encode (car args))
											(cdr args)) ".")) 'attr)

(! trans::js::regist processor "new Symb(\"javascript\")"
   (trans::js::encode ''javascript))

; TODO re-replace ascii code to bads(original symbol)
; ex util__3A3A__sort -> util::sort
(! trans::js::regist load (do (load (car args))
							(trans::js::encodetop (senva::readtop
													(file::read (car args))))))

(! trans::js::regist-func list l)
(! trans::js::regist-func int lint)
(! trans::js::regist-func float lfloat)
(! trans::js::regist-func to-list to_list)
(! trans::js::regist-func to-vect to_vect)
(! trans::js::regist-func to-queu to_queu)
(! trans::js::regist-func apply lapply)
(! trans::js::regist-func throw lthrow)
(! trans::js::regist-func empty lempty)
(! trans::js::regist-func print llprint)
(! trans::js::regist-func prin llprin)
(! trans::js::regist-func type ltype)
(! trans::js::regist-func getat lgetat)
(! trans::js::regist-func setat lsetat)

(! trans::js::regist-op and " && " t 'land)
(! trans::js::regist-op or " || " nil 'lor)
(! trans::js::regist-op + " + " 0 'add)
(! trans::js::regist-op - " - " 0 'sub)
(! trans::js::regist-op * " * " 1 'mul)
(! trans::js::regist-op / " / " 1 'div)
(! trans::js::regist-op % " % " 0 'mod)

(! trans::js::regist-func > gt)
(! trans::js::regist-func < lt)
(! trans::js::regist-func >= ge)
(! trans::js::regist-func <= le)

; TODO replace bads to ascii code in 16n
; ex push! -> push__21__
;    util::sort -> util__3A3A__sort
;    map->hash -> map__2D3E__hash
(define trans::js::rename-symb
  (! let ((bads (to-list " \"#%&'(),.:;=?@[\\]^`{|}~"))
		  (bbads (to-list " \"#%&'(),.:;=?@[\\]^`{|}~!*+-/<>"))
		  (underbar (car (to-list "_"))))
	 (lambda (sym)
	   (if (equal 1 (length sym))
		 (if (find (car (to-list sym)) bads) '_ sym)
		 (symbol (map (! fn (if (find $0 bbads) underbar $0)) (to-list sym)))))))

(define trans::js::seekdefine
  (lambda (expr)
	(if (not (atom expr))
	  (if (eq 'define (car expr))
		(list expr)
		(append (trans::js::seekdefine (car expr))
				(trans::js::seekdefine (cdr expr)))))))

(define trans::js::encodetop
  (lambda (expr_)
	(! let* ((expr (maptree (! fn (if (eq '<symb> (type $0))
									(trans::js::rename-symb $0) $0)) expr_))
			 (globals (trans::js::seekdefine expr)))
	   (join (append (map (! fn (sprint "let " (cadr $0) " = nil")) globals)
					 (list (trans::js::encode expr))) "; "))))

