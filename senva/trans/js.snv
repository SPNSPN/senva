(load "senva/interpreter.snv")
(load "senva/file.snv")

(define trans::js::encode
  (lambda (expr)
	(if (atom expr)
	  (! aif (cadr (assocdr trans::js::env expr)) (sprint it) (trans::js::put expr))
	  (if (eq '<symb> (type (car expr)))
		(! aif (car (assocdr trans::js::env (car expr)))
		   (it (cdr expr))
		   (sprint (car expr) "(" (trans::js::array (cdr expr)) ")"))
		(sprint "(" (trans::js::encode (car expr)) ")"
				"(" (trans::js::array (cdr expr)) ")")))))

;(! let ((esc-seqs (zip (to-list "\\\"\a\b\f\n\r\t\v\0") (to-list "\\\"abfnrtv0")))
(define trans::js::escape
  (! let ((esc-seqs (zip (to-list "\\\"\a\b\f\n\r\t\v\0")
						 (map to-list '("\\\\" "\\\"" "\\x07" "\\b" "\\f"
										"\\n" "\\r" "\\t" "\\v" "\\0"))))
		  (esc (car (to-list "\\"))))
	 (lambda (str) (string (reduce (! fn (! aif (assoc esc-seqs $1)
											(append (cadr it) $0)
											(cons $1 $0)))
								   (nreverse (to-list str)) ())))))

(define trans::js::put
  (lambda (obj)
	(if (eq '<strn> (type obj))
	  (sprint "\"" (trans::js::escape obj) "\"")
	  (sprint obj))))

(define trans::js::quote-put
  (lambda (obj)
	(! case (type obj)
	   ('<symb> (sprint "intern(\"" obj "\")")
		'<cons> (sprint "new Cons("
						(trans::js::quote-put (car obj)) ", "
						(trans::js::quote-put (cdr obj)) ")")
		t (trans::js::put obj)))))

(define trans::js::quasiquote-put
  (lambda (obj)
	(! case (type obj)
	   ('<symb> (sprint "intern(\"" obj "\")")
		'<cons> (if (eq 'unquote (car obj))
				  (trans::js::encode (cadr obj))
				  (reduce
					(lambda (acm e)
					  (if (eq 'splicing (car e))
						(sprint "nconc(" (trans::js::encode (cadr e)) ", " acm ")")
						(sprint "nconc(l(" (trans::js::quasiquote-put e) "), " acm ")")))
					(reverse obj) "nil"))
		t (trans::js::put obj)))))

(define trans::js::array
  (lambda (arr) (join (map trans::js::encode arr) ", ")))

(define trans::js::bind-args
  (! letrec ((seekform (lambda (tree acc)
						 (if (atom tree)
						   (list (list acc tree))
						   (append (seekform (car tree) (cons 'safecar acc))
								   (if (cdr tree)
									 (seekform (cdr tree) (cons 'safecdr acc)))))))
			 (shiftargs (lambda (rargs cnt)
						 (if rargs
						   (if (atom rargs)
							 (list (sprint "let " rargs
										   " = vect2cons(__sys_args.slice(" cnt "))"))
							 (append (map (lambda ((accessor sym))
											(sprint "let " sym " = "
													(join (map (! fn (sprint $0 "("))
															   accessor) "")
													"__sys_args[" cnt "]"
													(join (times (length accessor)
																 ")") "")))
										  (seekform (car rargs)))
									 (shiftargs (cdr rargs) (+ cnt 1))))))))
   (lambda (args)
	 (if (atom args)
	   (list (sprint "let " args " = vect2cons(Array.from(arguments))"))
	   (cons "let __sys_args = Array.from(arguments)"
			 (shiftargs args 0))))))

(define trans::js::env ())
(define trans::js::regist
  (lambda (sym form alt)
	`(! push trans::js::env (list ',sym (lambda (args) ,form) ,alt))))

(define trans::js::regist-func
  (lambda (sym fsym)
	`(! push trans::js::env
		(list ',sym
			  (lambda (args) (sprint ',fsym "(" (trans::js::array args) ")"))
			  ',fsym))))

(define trans::js::regist-op
  (lambda (sym op default alt)
	`(! push trans::js::env
	   (list ',sym
			  (lambda (args)
				(if (> 1 (length args))
				  (sprint ,default)
				  (sprint "(" (join (map trans::js::encode args) ,op) ")")))
			  ,alt))))

(! trans::js::regist if (sprint "(" (trans::js::encode (car args)) " !== nil)"
						" ? " (trans::js::encode (cadr args))
						" : " (trans::js::encode (caddr args)))
   "seekenv(genv, intern(\"if\"))")

(! trans::js::regist quote (trans::js::quote-put (car args))
   "seekenv(genv, intern(\"quote\"))")

(! trans::js::regist lambda (if (flatlistp (car args))
					  (sprint "(function ("
							  (trans::js::array (car args)) ") {"
							  "return " (trans::js::encode (cadr args)) "})")
					  (sprint "(function () { try {"
							  (join (map (! fn (sprint $0 "; "))
										 (trans::js::bind-args (car args))) "")
							  "return " (trans::js::encode (cadr args))
							  "} catch (__sys_erro) {throw new Erro(ErroId.Type, `cannot bind: "
							  (car args)
							  " and ${lprint(vect2cons(Array.from(arguments)))}`)}})"))
   "seekenv(genv, intern(\"lambda\"))")

; !
(! trans::js::regist __21__ (trans::js::encode (senva::expand-syntax-proc
									(car args) (cdr args) (environment)))
   "seekenv(genv, intern(\"!\"))")

(! trans::js::regist define (sprint "(function () {"
							(car args) " = " (trans::js::encode (cadr args))
							"; return " (trans::js::quote-put (car args)) "})()")
   "seekenv(genv, intern(\"define\"))")

(! trans::js::regist setq (sprint "(function () {"
						  (car args) " = " (trans::js::encode (cadr args))
						  "; return " (car args) "})()")
   "seekenv(genv, intern(\"setq\"))")

(! trans::js::regist do (! let ((jscs (map trans::js::encode args)))
						   (sprint "(function () {"
								   (join (rcons (tail-drop jscs 1)
												(sprint "return " (back jscs)))
										 "; ") "})()"))
   "seekenv(genv, intern(\"do\"))")

(! trans::js::regist quasiquote
   (trans::js::quasiquote-put (car args))
   "seekenv(genv, intern(\"quasiquote\"))")

(! trans::js::regist catch (sprint "(function () {try {return "
						   (trans::js::encode (cadr args))
						   "} catch (__sys_erro) {return "
						   (trans::js::encode (car args))
						   "(__sys_erro.eid, __sys_erro.estr)}})()")
   "seekenv(genv, intern(\"catch\"))")

(! trans::js::regist environment "genv" "seekenv(genv, intern(\"environment\"))"); TODO

(! trans::js::regist js (car args) 'eval)

(! trans::js::regist new (sprint "new " (car args)
							   "(" (trans::js::array (cdr args)) ")") 'lnew)

; ->
(! trans::js::regist __2D3E__ (sprint (join (cons (trans::js::encode (car args))
											(cdr args)) ".")) 'attr)

(! trans::js::regist processor "intern(\"javascript\")"
   (trans::js::encode ''javascript))

; TODO re-replace ascii code to bads(original symbol)
; ex util__3A3A__sort -> util::sort
(! trans::js::regist load (do (load (car args))
							(trans::js::encodetop (senva::readtop
													(file::read (car args))))))

(! trans::js::regist-func list l)
(! trans::js::regist-func int lint)
(! trans::js::regist-func float lfloat)
(! trans::js::regist-func to-list to_list)
(! trans::js::regist-func to-vect to_vect)
(! trans::js::regist-func to-queu to_queu)
(! trans::js::regist-func apply lapply)
(! trans::js::regist-func throw lthrow)
(! trans::js::regist-func empty lempty)
(! trans::js::regist-func print llprint)
(! trans::js::regist-func prin llprin)
(! trans::js::regist-func type ltype)
(! trans::js::regist-func getat lgetat)
(! trans::js::regist-func setat lsetat)

(! trans::js::regist-op and " && " t 'land)
(! trans::js::regist-op or " || " nil 'lor)
; +
(! trans::js::regist-op __2B__ " + " 0 'add)
; -
(! trans::js::regist-op __2D__ " - " 0 'sub)
; *
(! trans::js::regist-op __2A__ " * " 1 'mul)
; /
(! trans::js::regist-op __2F__ " / " 1 'div)
; %
(! trans::js::regist-op __25__ " % " 0 'mod)

; >
(! trans::js::regist-func __3E__ gt)
; <
(! trans::js::regist-func __3C__ lt)
; >=
(! trans::js::regist-func __3E3D__ ge)
; <=
(! trans::js::regist-func __3C3D__ le)

; TODO replace bads to ascii code in 16n
; ex push! -> push__21__
;    util::sort -> util__3A3A__sort
;    map->hash -> map__2D3E__hash
(define trans::js::rename-symb
  (! let ((bad-chs (to-list " \"#%&'(),.:;=?@[\\]^`{|}~!*+-/<>"))
		  (underbar (car (to-list "_"))))
	 (! letrec ((split-bads
				  (lambda (chs))))
		(lambda (sym)
		  (! let (((goods . bads) (split-bads (to-list sym))))
			 )))))

(define trans::js::unname-symb
  (lambda (sym)
	()))

(define trans::js::seekdefine
  (lambda (expr)
	(if (not (atom expr))
	  (if (eq 'define (car expr))
		(list expr)
		(append (trans::js::seekdefine (car expr))
				(trans::js::seekdefine (cdr expr)))))))

(define trans::js::encodetop
  (lambda (expr_)
	(! let* ((expr (maptree (! fn (if (eq '<symb> (type $0))
									(trans::js::rename-symb $0) $0)) expr_))
			 (globals (trans::js::seekdefine expr)))
	   (join (append (map (! fn (sprint "let " (cadr $0) " = nil")) globals)
					 (list (trans::js::encode expr))) "; "))))

